# Scheduling della PC

Le fasi di un processo si alternano tra l'uso della pc e l'attessa per l'uso della CPU.

L'insieme di questa pratica è chiamata **Scheduling dell CPU**

Ci sono processi **CPU-bound**: usano molto la CPU e poco i dispositivi I/O
Processi **I/O** usano poco la CPU e molto i dispositivi

Consideriamo la situazione in cui un processo utente
abbandona la CPU. Il SO si sveglia e deve decidere a
quale, fra i processi in Coda di Ready (processi che
diciamo essere ready to run), assegnare la CPU.
• Questa operazione è detta Scheduling della CPU, e viene
fatta dal modulo del SO detto scheduler.
• Quando interviene lo scheduler per scegliere il successivo
processo a cui assegnare la CPU? Possiamo considerare
quattro situazioni, che ci porteranno a definire i concetti di
scheduling con e senza diritto di prelazione

1. il processo che sta usando le CPU passa volontariamente dallo sato di running allo stato di waiting
2. Il processo che sta usando la CPU termina

In questi due casi p sufficiente per implementare il multi-tasking.

Lo scheduler devi intervenire quando un processo possa impossessi della CPU a tempo indeterminato. IL processo **viene obbligata a passare** dallo stato di running allo stato di ready.

4. un processo PX entra in coda di ready arrivando da una coda di wait oppure è stato appena lancianto. ci sono due ragioni per cui il SO interviene:
   1. il proccessi non si spostano da soli nelle code, i loro PCB sono gestiti dal SO.
   2. Se un processo è importante del processo in esecuzione, il SO toglie quest'ultimo dalla CPU e manda in esecuzione il processo chiamato.

Quando un sistema interviene solo nei casi 1 e 2 si parla di:
**Scheduling senza (diritto di) prelazione (in inglese: Non-preemptive scheduling)**
Quando il sistema interviene anche nei casi 3 e 4 si parla di
**Scheduling con (diritto di) prelazione (in inglese: preemptive scheduling)**

## Scheduling con e senza prelazione

LO scheduling preemptive è più sciuro perchè abbiamo più controllo e più sicurezza rispetto all'altra parta.

Con l'introduzione del timer un processo chiamante un system call si interrompe lascia una system call chiamata a metà se un'altro processo usa la stessa system call il blocco dati potrebbe essere persa.

Il metoodo per bypassare questo modo è disabilitare gli inerrupt. Questo vuol dire che mentre una system call è chimata gli interrupt vengono disabilitati.

## Criteri di scheduling

Per implementare possiamo guardare questi parametri:
Massimizzare l'utilizzo della CPU nell unità di tempo anche se dipende dal carico massimizzare il **Throughput** ossia le produttività del sistema; il numero di processi completati, minimizzare il **Tempo di risposta** dopo quanto tempo un programma parte. Minimizzare il **Turnaround time**: ossia il tempo medio di **completamento** di un processo, da quando entra in coda ready per la prima volta e quando termina. (questo ultimo indicatore è molto importante). Minimizzare il **waiting time**, ossia il tempo di attesa che un processo trascorre in coda di ready.

## Algoritmi di scheduling

• First Come, First Served (scheduling per ordine di arrivo)
• Shortest Job First (scheduling per brevità)
• Priority scheduling (scheduling per priorità)
• Round Robin (scheduling circolare)
• Multilevel Queue (scheduling a code multiple)
• Multilevel Feedback Queue (scheduling a code multiple con retroazione)

### Frist come Frist served (FCFS)

È l'algoritmo più semplice da implementare. Manda in esecuzione il programma in testa alla coda.

Questo algoritmo non è prentive, cioè la cpu potrebbe essere impossessata da un solo processo

### Shortes Job Frist (SJF)

Si esamina la durata del **prossimo** brust(uso) di CPU di ciascuno processo in RQ e si assegna l cpu al processo con il burst di durata minima.

Può essere pre emptive e non pre emptive.

nel caso preemptive, se arriva in coda di ready un processo il cui burst time è inferiore a quanto rimane da eseguire al processo attualmente running, quest’ultimo viene interrotto e la CPU passa al nuovo processo. Questo schema è noto come Shortest-Remaining-Time-First (SRTF)

C'è un grande problema però che il processo di brust non l'ho conosciamo. Quindi il SJF **non è implementabile** dato il fatto della non conoscenza del brust.

---

Questi due algoritmi visti sono: **FCFS** è il peggiore algoritmo il **SJB** è il migliore. Quindi più un algoritmo si allonatan 
TODO finire

### Scheduling a priorità

Un processo non verrà mai scelto dall ascheduler si dice va in starvation (muore di fame), per fixxare questo problema si usa un meccanismo di aging: il SO aumenta la priorità di un processo PX man man che trascorre il tempo
