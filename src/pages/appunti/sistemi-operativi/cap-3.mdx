---
capitolo: 3
layout: "../../../layouts/PostsLayout.astro"
---

# I Processi 3.0.0

{/* kernel: gestione processi, memoria primaria e secondaria */}

:::def
Il **processo** √® l‚Äôunit√† di lavoro del sistema operativo.
:::

> libro 3.1.1

Ci√≤ che fa un qualsiasi SO √® innanzi tutto amministrare la
vita dei processi che sono eseguiti da un computer.

Un processo √® quasi come un programma (informalmente sono la stessa cosa) in esecuzione con la differenza che un processo √® pi√π oggetto di un semplice programma.

Un processo ha una struttura in memoria primaria (in un‚Äôarea assegnatagli dal SO) suddivisa in pi√π parti (fig. 3.1):

- Codice da eseguire (il ‚Äútesto‚Äù) +
- dati +
- stack (per le chiamate alle procedure / metodi e il passaggio dei parametri) +
- heap (la memoria dinamica)

Ci processi che hanno lo stesso codice; un programma pu√≤ generare pi√π processi.

:::nb
Differenza tra **processo** e **programma** √® che il processo √® un'entit√† attiva invece il programma √® un'entit√† statica
:::

Alcuni sinonimi di processo sono: task, job def occupa

## Gli stati dei processi 3.1.2

Da quando nasce a quando termina un processo cambia di stato. Lo stato di un processo evolve a causa del codice eseguito e dall'azione del sistema operativo, alcuni stati sono:

- **Nuovo**: Il processo √® appena nato nel sistema e il SO sta allestendo le strutture di dati necessari per amministrarlo
- **Ready** (to run): il processo √® pronto per entrare in esecuzione, quando sar√† il suo turno
- **Running**: La cpu sta eseguendo codice del processo
- **Waiting**: Il processo ha lasciato le CPU e attende il completamento di un evento
- **Terminated**: il processo √® terminato, il SO sta recuperandole strutture dati e le aree di memoria liberate.

Questo diagramma fa vedere in che modo un processo cambia di stato:

{/* TODO da aggiungere il diagramma [Diagramma] */}

## Process Control Block 3.1.3

Per ogni processo il SO crea una struttura dati il **Process Control Block**, che serve ad amministrare il processo stesso.
I dati sono:

- **ID** che √® il numero univoco del processo
- Lo **stato** del processo
- Il **contenuto dei registri** della CP salvati nel momento in cui il SO **sospende** il processo
- I **limiti di memoria** che il processo ha nella RAM
- I file e gli altri **dispositivi I/O** correntemente in uso del processo
- Le informazioni per lo scheduling della CPU (ad esempio quanta CPU ha usato fino a quel momento in un processo)

In sintesi, il PCB si usa semplicemente come deposito per tutte le informazioni relative ai vari processi.

## Scheduling Process

Per implementare il multitasking e il time-sharing il SO ha bisogno di implementare lo Scheduling

:::def
Il SO deve decidere periodicamente quale sar√† il prossimo processo a cui assegnare la CPU esso viene chiamato **Scheduling**
:::

Nel momento in cui il processo √® in esecuzione ha a disposizione tutta la macchina. Il SO √® incaricato a passare da processo a processo, salvando e ripristinando i dati del processo in questione.

### Il cambio di contesto

Per commutare la CPU tra due processi il SO deve:

1. Riprendere il controllo della CPU (ad esempio attraverso il meccanismo del timer)
2. Con l'aiuto dell hardware della CPU, salvare lo stato corrente della computazione del processo che lascia la CPU, ossia copiare il valore del PC e degli altri registri.

Il contex switch richiede tempo, e nel momento in cui cambia programma la CPU va in hoverhead cio√® ci sar√† un momento morto üíÄ che la CPU **non esegue nessun programma** (se non il codice del sistema operativo).

### Code di processi

Ci sono varie _code di processi_. Per spiegarla immaginiamoci questa situazione:

Nel momento in cui un computer √® acceso alcuni processi potrebbero voler essere eseguiti nello stesso instante, cosa possibile. Per risolvere il problema la CPU deve decidere quali processi far partire per primi e quali far partire dopo. I processi creeranno una **coda di processi** nel quale il programma aspetta di essere eseguito dalla CPU.
La coda pi√π importante infatti √® la **coda di ready** nel quale un programma √® in attesa di essere eseguito; ci sono per√≤ altre code nel nostro sistema, come quella del programma che esce dall'esecuzione e il SO mette questo processo in una coda ben determinata che possono essere:

Quando un processo rilascia la CPU, ma non termina e non torna in ready queue, vuol dire che si √® messo in attesa di ‚Äúqualcosa‚Äù, e il SO lo ‚Äúparcheggia‚Äù in una tra $n$ possibili code, che possiamo dividere in due grandi categorie:

- **device queues**: code di processi in attesa data dell'uso di un dispositivo I/O. Una coda per ciascun dispositivo (La stampante)
- **code di waiting**: code di processi in attesa che si verifichi un certo evento. Una code per ciascun evento (ci torneremo pi√π avanti)

Il SO √® l'incaricato a gestire in quale coda il processo deve andare.

{/* TODO [diagramma di accodamento]  mettere il diagramma */}

Il diagramma di riformulazione di stati pu√≤ anche essere rappresentato come diagramma di **accodamento** in cui i processi si muovono fra le varie code.

Quando i processi si trovano nella coda si trovano nella coda della ready to run si attiva un componente **cpu scheduler** il quale sceglier√† quale sar√† il processo da eseguire

### CPU scheduler

Il **CPU scheduler** √® un componente incaricato alla gestione dell'ordine di esecuzione dei processi, √® un componente molto veloce ed √® il cuore del time sharing. (Sar√† l'argomento del nostro Cap. 5).
Ogni sistema operativo ha almeno una System call delegata alla creazione di processi, ogni processo √® creato da un altro processo usando la system call relativa. (√à la system call pi√π importante del SO)

Il processo che crea il processo si chiama **processo padre (o parent)**.

Il processo creato √® detto **processo figlio 8o child**

Poich√© ogni processo pu√≤ a sua volta creare altri processi si crea una struttura ad albero chiamato **albero di processi**.

Quando un processo crea un nuovo processo il SO:

- Gli assegna un Processo ID o **PID**
- recupera dall'hard disk il codice da eseguire e lo porta in RAM.
- ALloca un nuovo [PCB](#process-control-block-313) e lo inizializza con le informazioni relative al nuovo processo.
- inserisce il [PCB](#process-control-block-313) in coda di ready.

### Creazione di un processo

Ogni sistema operativo ha la sua SC per generare un processo lo sviluppatore del SO deve decidere come implementarlo, alcune domande sono:

1. Che cosa fa il processo padre quando ha generato un processo figlio?
   - prosegue la sua esecuzione in modo concorrente all‚Äôesecuzione del processo figlio
   - si ferma, in attesa del completamento dell‚Äôesecuzione del processo figlio.
2. Quale codice esegue il processo figlio?
   - al processo figlio viene dato lo stesso codice del padre
   - al codice figlio viene dato un nuovo programma con eventualmente nuovi dati

```c
int main(){                 /* fig. 3.8 modificata */
    pid_t pid, childPid;    /* pid_t il tipo della variabile potrebbe essere int */
    pid = fork();           /* genera un nuovo processo */
    printf("questa la stampano padre e figlio");

    if (pid == 0)
    {                       /* processo figlio */
        printf("processo figlio");
        execlp("/bin/ls", "ls",NULL);
    }
    else
    {                       /* processo padre */
        printf("sono il padre, aspetto il figlio");
        childpid = wait(NULL);
        printf("il processo figlio √® terminato");
        exit(0);
    }
}
```

Spiegazione del codice:

1. Alloca un nuovo PCB per il processo figlio, e gli assegna un nuovo PID; cerca un‚Äôarea libera in RAM e vi copia le strutture dati e il codice del processo (si veda pi√π avanti): queste copie verranno usate dal processo figlio.
2. Inizializza il PC del figlio con l‚Äôindirizzo della prima istruzione successiva alla fork. 3. Nella cella di memoria associata alla variabile che riceve il risultato della fork del processo figlio scrive 0
3. Nella cella di memoria associata alla variabile che riceve il risultato della fork del processo parent scrive il PID del figlio
4. Mette i processi parent e figlio in coda di ready.

#### Alcune system calls

**eeclp**: riceve in input un puntatore ad un file contenente codice eseguibile. Il processo che la invoca prosegue eseguendo il codice specificato, senza pi√π ritornare alla porzione di codice che viene dopo la execpl.

**wait**: invocata da un processo parent, lo sospende fino alla terminazione del processo figlio. La wait restituisce il PID del figlio appena terminato.

**exit**: provoca la terminazione istantanea del processo che lo invoca

### Terminazione di un Processo

Un processo termina dopo l'esecuzione dall'ultima istruzione del codice. Un'altra via √® chiamare il metodo `exit()` (in `C`).

Di sooti un pu√≤ processo pu anche uccidere esplicitamente un'altro processo. La system call `kill` in unix e `Terminate Process` in windows.

### Comunicazione tra processi

Ci sono due tipi di processi tra di loro:

- indipendenti: non si infulenzano l'un l'altro
- cooperanti: si influenzano l'un l'altro allo scopo di scambiarsi informazioni e/o portare avanti una elaborazione che √® stata suddivisa tra i vari processi per ragione di efficienza e/o modularit√†.

Il SO deve offrire un servizio di comunicazione e sincronizzazione per gestire questi processi.

Un classico problema di processi cooperanti:

un processo _produttore_ produzione informazioni che sono consumante da processo _consumatore_ le informazioni vengono depositate e prelevate da un buffer di dimensione limitata.

Un esempio di "produttore e consumatore" √® il compilatore che prende il codice e produce il codice eseguibile.

```c
#define SIZE 10
typedef struct {...} item;
item buffer [SIZE]; (shared array)
int in = 0, out = 0;
```

Buffer circolare di Size item con due puntatori _in_ e _out_:

- valore corrente di in: prossimo item libero;
- valore corrente di out: primo item pieno;
- condizione di buffer vuoto: in=out;
- condizione di buffer pieno: in+1 mod SIZE = out

Produttore:

```c
item nextp;
repeat
<produci un nuovo item in nextp>
while (in+1 mod SIZE== out) do no_op; /* buffer full */
buffer[in] = nextp;
in = in+1 mod SIZE;
until false;
```

consumatore

```c
item nextc;
repeat
while (in == out) do no_op; /*buffer empty */
nextc = buffer[out];
out = out+1 mod SIZE;
<consuma l'item in nextc>
until false;
```

C'√® un problema: la varibaile IN e OUT √® sono usate sia dal consumatore che dal produttore.

L'incaricato alla gestione di questo problema √® il sistema opertiva che implementa **Inter-Process Communication (IPC)**. Opportuna System call che permettono a due (o pi√π processi di comunicare) scambiandosi messaggio o usare la stessa memoria condivisa.

Per esempio per lo scambio di messaggio viene:

- line = `msgget()`
- `send(message,line,processo-id)`
- `receive(message,line,process-id)`
